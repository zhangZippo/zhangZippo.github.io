(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{302:function(e,r,a){"use strict";a.r(r);var t=a(1),s=Object(t.a)({},function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"一些js细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些js细节","aria-hidden":"true"}},[e._v("#")]),e._v(" 一些js细节")]),e._v(" "),a("h3",{attrs:{id:"array-length"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#array-length","aria-hidden":"true"}},[e._v("#")]),e._v(" Array.length")]),e._v(" "),a("p",[e._v("设置 length 属性会改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部的元素将丢失。\n如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部，它们的值为 undefined。\n这意味着你截取尾部可以采用length -1 的方式而不需要使用substring,splice等方法。")]),e._v(" "),a("h3",{attrs:{id:"array-every和array-some"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#array-every和array-some","aria-hidden":"true"}},[e._v("#")]),e._v(" Array.every和Array.some")]),e._v(" "),a("p",[e._v("对于数组对象来说，它的迭代方式非常多，如each,filter,reduce 等等吧，这两个方法是做什么用的呢？\n官方的说法是：测试数组的所有元素是否都通过了指定函数的测试。这两个方法都不会改变原有数组的结构")]),e._v(" "),a("blockquote",[a("p",[e._v("语法：arr.every(callback, [thisArg])")])]),e._v(" "),a("p",[e._v("第一个参数为回调函数，第二个参与用以替代callback中this的指向，callback 被调用时传入三个参数：元素值，元素的索引，原数组。这和一般的迭代方法差不多了。举例：下例检测数组中的所有元素是否都大于 0")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function isBigThenZero(element, index, array) {\n\n  return(element > 0);\n\n}\n\nvar zero = [-12, 5, -8, 13, 4].every(isBigThenZero); // passed is false\n\nzero = [12, 54, 18, 1, 4].every(isBigThenZero); // passed is true\n")])])]),a("blockquote",[a("p",[e._v("every在用法上与some基本一致，他们不同的点其实从字面上也能看出一些，every返回true的要求是数组中每一项都必须满足条件，而some是只要又一个元素满足条件就会返回true。从这两个方法我们可以看出当我们需要对数组元素做一些特定的验证又不希望对数组有改动时，可以采用这两种方法。如果我们选择使用each和for循环去做校验，可能还需要引入中间变量，不如这样简洁。")])]),e._v(" "),a("h3",{attrs:{id:"对象的可枚举性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的可枚举性","aria-hidden":"true"}},[e._v("#")]),e._v(" 对象的可枚举性")]),e._v(" "),a("blockquote",[a("p",[e._v("for...in循环：只遍历对象自身的和继承的可枚举的属性。")])]),e._v(" "),a("blockquote",[a("p",[e._v("Object.keys()：返回对象自身的所有可枚举的属性的键名。")])]),e._v(" "),a("blockquote",[a("p",[e._v("Object.entries()：方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。")])]),e._v(" "),a("blockquote",[a("p",[e._v("JSON.stringify()：只串行化对象自身的可枚举的属性。")])]),e._v(" "),a("blockquote",[a("p",[e._v("Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。")])]),e._v(" "),a("h3",{attrs:{id:"json"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json","aria-hidden":"true"}},[e._v("#")]),e._v(" JSON")]),e._v(" "),a("p",[e._v("JSON.stringify(value,[,replacer[,space]]) 这个我们常用的序列化方法是有3个参数的，中间的参数用于序列化时的处理，第三个参数可以用于美化输出的字符串，比如增加2个空格缩进")]),e._v(" "),a("blockquote",[a("p",[e._v("mdn解释：")])]),e._v(" "),a("blockquote",[a("p",[e._v("value")])]),e._v(" "),a("p",[e._v("将要序列化成 一个JSON 字符串的值。")]),e._v(" "),a("blockquote",[a("p",[e._v("replacer 可选")])]),e._v(" "),a("p",[e._v("如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化；关于该参数更详细的解释和示例，请参考使用原生的 JSON 对象一文。")]),e._v(" "),a("blockquote",[a("p",[e._v("space 可选")])]),e._v(" "),a("p",[e._v("指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格。")]),e._v(" "),a("h3",{attrs:{id:"foreach"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#foreach","aria-hidden":"true"}},[e._v("#")]),e._v(" forEach")]),e._v(" "),a("p",[e._v("forEach方法在循环至结尾元素前不能终止循环，内部使用return 只是跳出本次循环，如一定要跳出循环，可以采用抛出异常的方式来终止循环。")]),e._v(" "),a("p",[e._v("持续补充中......")])])},[],!1,null,null,null);s.options.__file="2019-04-07somedetailofjs.md";r.default=s.exports}}]);